<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>List UI</title><style type="text/css">body{
margin:40px auto;
max-width:650px;
line-height:1.6;
font-size:18px;
color:#eee;
background-color:#111;
padding:0 10px
}
textarea, input, button {
color:#eee;
background-color:#111;
}
</style>
</head>

<body>
    <div>
        <form id="fileForm">
            <label for="fileInput">Choose a list file:</label>
            <input type="file" id="fileInput" name="fileInput" />
        </form>
    </div>
    <div id="outputDiv">

    </div>
    <script>
        let listStates = [];

        const parseList = (fileContent) => {
            //
            //  Parse The List
            //

            const STATE_INITIAL = 0;
            const STATE_HEADER = 1;
            const STATE_LIST_IDENT = 2;
            const STATE_LIST_ITEM = 3;
            const STATE_SUBLIST_IDENT = 4;
            const STATE_SUBLIST_ITEM = 5;

            let state = STATE_INITIAL;
            let tempHeader = "";
            let tempListItem = "";
            let headers = {};
            let currentListItem = {};
            let detectedIndentDepth = 0;
            let currentIndentDepth = 0;
            let currentSublistDepth = 0;

            const TAB_WIDTH = 4;
            const SPACE_WIDTH = 1;

            for (const c of fileContent) {
                switch (state) {
                    case STATE_INITIAL:
                        switch (c) {
                            case "#":
                                state = STATE_HEADER;
                                tempHeader = "";
                            break;
                            default:
                                console.log("unhandled:" + c)
                            break;
                        }
                    break;
                    case STATE_HEADER:
                        switch (c) {
                            case "\n":
                                tempHeader = tempHeader.trim()

                                if (tempHeader) {
                                    state = STATE_LIST_IDENT;
                                    // TODO? Bother to handle identical headers?
                                    headers[tempHeader] = [];
                                    tempListItem = "";
                                } else {
                                    state = STATE_INITIAL;
                                    tempHeader = "";
                                    tempListItem = "";
                                }
                            break;
                            default:
                                tempHeader += c;
                            break
                        }
                    break;
                    case STATE_LIST_IDENT:
                        switch (c) {
                            case "#":
                                state = STATE_HEADER;
                                if (tempListItem) {
                                    headers[tempHeader].push(tempListItem);
                                }
                                tempHeader = "";
                            break;
                            case "\n":
                                tempListItem = tempListItem.trim()

                                if (tempListItem) {
                                    // TODO handle sub items properly. Support infinite levels?
                                    currentListItem = { name: tempListItem, subItems: []};
                                    headers[tempHeader].push(currentListItem);
                                }
                                currentIndentDepth = 0;
                                tempListItem = "";
                            break;
                            case "\t":
                                currentIndentDepth += TAB_WIDTH - SPACE_WIDTH;
                                 // fallthrough
                            case " ":
                                currentIndentDepth += SPACE_WIDTH;
                                state = STATE_SUBLIST_IDENT;
                            break;
                            default:
                                tempListItem += c;
                                state = STATE_LIST_ITEM;
                            break;
                        }
                    break;
                    case STATE_LIST_ITEM:
                        switch (c) {
                            case "#":
                                state = STATE_HEADER;
                                if (tempListItem) {
                                    headers[tempHeader].push(tempListItem);
                                }
                                tempHeader = "";
                            break;
                            case "\n":
                                tempListItem = tempListItem.trim()

                                if (tempListItem) {
                                    // TODO handle sub items properly. Support infinite levels?
                                    currentListItem = { name: tempListItem, subItems: []};
                                    headers[tempHeader].push(currentListItem);
                                }
                                currentIndentDepth = 0;
                                tempListItem = "";
                                state = STATE_LIST_IDENT;
                            break;
                            default:
                                tempListItem += c;
                            break;
                        }
                    break;
                    case STATE_SUBLIST_IDENT:
                        switch (c) {
                            case "#":
                                state = STATE_HEADER;
                                if (tempListItem) {
                                    headers[tempHeader].push(tempListItem);
                                }
                                tempHeader = "";
                            break;
                            case "\n":
                                state = STATE_LIST_ITEM;
                                currentIndentDepth = 0;
                                currentSublistDepth = 0;
                                tempListItem = "";
                            break;
                            case "\t":
                                currentIndentDepth += 3;
                                 // fallthrough
                            case " ":
                                currentIndentDepth += 1;
                                state = STATE_SUBLIST_IDENT;
                            break;
                            default:
                                // Some word character to start the list item
                                if (!detectedIndentDepth) {
                                    detectedIndentDepth = currentIndentDepth;
                                }

                                currentSublistDepth = Math.floor(currentIndentDepth / detectedIndentDepth)

                                state = STATE_SUBLIST_ITEM;
                                tempListItem += c;
                            break;
                        }
                    break;
                    case STATE_SUBLIST_ITEM:
                        switch (c) {
                            case "#":
                                state = STATE_HEADER;
                                if (tempListItem) {
                                    headers[tempHeader].push(tempListItem);
                                }
                                tempHeader = "";
                            break;
                            case "\n":
                                tempListItem = tempListItem.trim()

                                if (tempListItem) {
                                    let _depth = currentSublistDepth - 1;
                                    let _currentListItem = currentListItem;

                                    while(_depth > 0) {
                                        if (_currentListItem.subItems.length > 0) {
                                            _currentListItem = _currentListItem.subItems[_currentListItem.subItems.length - 1]
                                        } else {
                                            _currentListItem = undefined;
                                        }

                                        _depth -= 1;
                                    }

                                    if (_currentListItem) {
                                        _currentListItem.subItems.push({ name: tempListItem, subItems: []});
                                    }

                                }

                                state = STATE_LIST_IDENT;
                                currentIndentDepth = 0;
                                currentSublistDepth = 0;
                                tempListItem = "";
                            break;
                            default:
                                tempListItem += c;
                            break;
                        }
                    break;
                }
            }

            return headers;
        }

        const renderList = (listStates, i) => {
            let {
                headers,
                statsOutput,
                listOutput,
                options: {
                    renderMerged,
                    renderCartesianProduct
                }
            } = listStates[i];

            //
            //  Display the Parsed List
            //

            //  Display the Stats Above the List

            statsOutput.innerText = "";

            const headerKeys = Object.keys(headers);

            let rootCount = 0;
            let leafCount = 0;
            let mergedCount = 0;
            let mergedCartesianProductCount = 0;

            const countSubItems = (subItems) => {
                let total = 0;

                for (const subItem of subItems) {
                    if (subItem.subItems.length === 0) {
                        total += 1;
                    } else {
                        total += countSubItems(subItem.subItems);
                    }
                }

                return total;
            };

            const getAllSubsetNames = (subItems) => {
                // 32 levels will probably be enough for a while, and even that many is probablt too many
                if (subItems.length > 31) {
                    return [ "ERROR, Too many items: " + subItems.length ];
                } else if (subItems.length === 0) {
                    return [];
                }

                let output = [];

                let fullMask = (1 << subItems.length) - 1;

                let currentMask = 1;

                while (currentMask <= fullMask) {
                    let subItemSubSet = [];

                    let mask = currentMask;
                    let index = 0;
                    while (mask > 0) {
                        if (mask & 1) {
                            subItemSubSet.push(subItems[index]);
                        }

                        index += 1;
                        mask >>= 1;
                    }

                    let nestedNames = [];

                    let baseName = "";
                    let sep = "";
                    for (subItem of subItemSubSet) {
                        baseName += sep;
                        baseName += subItem.name;
                        sep = " ";
                    }
                    nestedNames.push(baseName);

                    for (subItem of subItemSubSet) {
                        const subsetNames = getAllSubsetNames(subItem.subItems);
                        const len = nestedNames.length;

                        for (let i = 0; i < len; i += 1) {
                            for (subsetName of subsetNames) {
                                nestedNames.push(nestedNames[i] + " " + subsetName)
                            }
                        }
                    }

                    output = output.concat(nestedNames);

                    currentMask += 1;
                }

                return output
            }

            const countSubItemsCartesianProduct = (subItems) => {
                let total = 0;

                for (const item of subItems) {
                    if (item.subItems.length > 0) {
                        const childNames = getAllSubsetNames(item.subItems);

                        // TODO figure out why we are getting redundant names, if we still are
                        total += new Set(childNames).size;
                    } else {
                        total += 1;
                    }
                }

                return total;
            };

            for (const headerName of headerKeys) {
                const listItems = headers[headerName];

                rootCount += listItems.length;

                mergedCount += 1;
                mergedCartesianProductCount += 1;

                if (listItems.length === 0) {
                    leafCount += 1;
                } else {
                    const count = countSubItems(listItems);
                    leafCount += count;
                    mergedCount += count;

                    const cartesianProductcount = countSubItemsCartesianProduct(listItems);
                    mergedCartesianProductCount += cartesianProductcount;
                }
            }

            statsOutput.innerText = `${rootCount} top level item${rootCount === 1 ? "" : "s"}, ${leafCount} items with no sub item${leafCount === 1 ? "" : "s"}, ${mergedCount} item${mergedCount === 1 ? "" : "s"} when merged, ${mergedCartesianProductCount} item${mergedCartesianProductCount === 1 ? "" : "s"} when merged with cartesian product`;

            //  Display the List Itself

            listOutput.innerText = "";

            const renderSubItems = (subItems, parent) => {
                for (const subItem of subItems) {
                    const subItemElem = document.createElement('li');
                    subItemElem.innerText = subItem.name;
                    parent.appendChild(subItemElem);

                    const ulElem = document.createElement('ul');
                    subItemElem.appendChild(ulElem);

                    renderSubItems(subItem.subItems, ulElem)
                }
            };

            const renderSubItemsMerged = (subItems, parent, parentName) => {
                for (const subItem of subItems) {
                    const name = parentName + " " + subItem.name;

                    if (subItem.subItems.length > 0) {
                        renderSubItemsMerged(subItem.subItems, parent, name)
                    } else {
                        const subItemElem = document.createElement('li');
                        subItemElem.innerText = name;
                        parent.appendChild(subItemElem);
                    }
                }
            };

            const renderSubItemsCartesianProduct = (subItems, parent, parentName) => {
                const childNames = getAllSubsetNames(subItems);

                // TODO figure out why we are getting redundant names
                for (childName of new Set(childNames)) {
                    const subItemElem = document.createElement('li');
                    subItemElem.innerText = parentName + " " + childName;
                    parent.appendChild(subItemElem);
                }
            }

            for (const headerName of headerKeys) {
                const headerElem = document.createElement('h3');
                headerElem.innerText = headerName;
                listOutput.appendChild(headerElem);

                const items = headers[headerName];

                const outerUlElem = document.createElement('ul');
                listOutput.appendChild(outerUlElem);

                for (const item of items) {
                    if (renderMerged) {
                        const itemElem = document.createElement('li');
                        itemElem.innerText = item.name;
                        outerUlElem.appendChild(itemElem);

                        if (item.subItems.length > 0) {
                            if (renderCartesianProduct) {
                                renderSubItemsCartesianProduct(item.subItems, outerUlElem, item.name);
                            } else {
                                renderSubItemsMerged(item.subItems, outerUlElem, item.name);
                            }
                        }
                    } else {
                        const itemElem = document.createElement('li');
                        itemElem.innerText = item.name;
                        outerUlElem.appendChild(itemElem);

                        const innerUlElem = document.createElement('ul');
                        itemElem.appendChild(innerUlElem);

                        renderSubItems(item.subItems, innerUlElem)
                    }
                }
            }
        };

        const fileForm = document.getElementById("fileForm");
        // We aren't allowed to reload the file automatically without user input
        // apparently, so reset the form to make that clearer.
        fileForm.reset();

        const fileInput = document.getElementById("fileInput");
        const outputDiv = document.getElementById("outputDiv");

        fileInput.addEventListener("change", () => {
            listStates = [];
            outputDiv.innerText = "";

            for (let i = 0; i < fileInput.files.length; i += 1) {
                const file = fileInput.files[i];

                const reader = new FileReader();

                reader.onload = (e) => {
                    // The content of the file as a text string
                    const fileContent = e.target.result + "\n"; // We add "\n" So we know we'll flush the last item

                    const headers = parseList(fileContent);

                    const optionsForm = document.createElement('form');
                    outputDiv.appendChild(optionsForm);

                    const statsOutput = document.createElement('output');
                    outputDiv.appendChild(statsOutput);

                    const listOutput = document.createElement('output');
                    outputDiv.appendChild(listOutput);

                    //
                    // Render the options form
                    //

                    const renderMergedCheckbox = document.createElement('input');
                    renderMergedCheckbox.type = "checkbox";
                    renderMergedCheckbox.id = "render-merged-" + i;
                    optionsForm.appendChild(renderMergedCheckbox);

                    const renderMergedLabel = document.createElement('label');
                    renderMergedLabel.htmlFor = renderMergedCheckbox.id;
                    renderMergedLabel.textContent = "Render nested entries as merged";
                    optionsForm.appendChild(renderMergedLabel);

                    renderCartesianProductCheckbox = document.createElement('input');
                    renderCartesianProductCheckbox.type = "checkbox";
                    renderCartesianProductCheckbox.id = "render-cartesian-product-" + i;
                    optionsForm.appendChild(renderCartesianProductCheckbox);


                    const updateForm = () => {
                        listStates[i].options.renderMerged = renderMergedCheckbox.checked;
                        listStates[i].options.renderCartesianProduct = renderCartesianProductCheckbox.checked;
                        renderCartesianProductCheckbox.disabled = !renderMergedCheckbox.checked;

                        renderList(listStates, i);
                    };
                    renderMergedCheckbox.addEventListener("change", updateForm);
                    renderCartesianProductCheckbox.addEventListener("change", updateForm);


                    const renderCartesianProductLabel = document.createElement('label');
                    renderCartesianProductLabel.htmlFor = renderCartesianProductCheckbox.id;
                    renderCartesianProductLabel.textContent = "Merge all combinations";
                    optionsForm.appendChild(renderCartesianProductLabel);

                    listStates.push({
                        headers,
                        statsOutput,
                        listOutput,
                        options: {
                            renderMerged: renderMergedCheckbox.checked,
                            renderCartesianProduct: renderCartesianProductCheckbox
                        }
                    });

                    updateForm();
                };

                reader.readAsText(file);
            }
        });
    </script>
</body>
</html>
